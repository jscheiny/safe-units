export interface ICommonSpec {
    minExponent: number;
    maxExponent: number;
}

export interface ICodeGenSpec extends ICommonSpec {
    operators: IPartialOperatorSpec[];
}

export interface IPartialOperatorSpec {
    fileNamePrefix: string;
    uncurriedTypeNamePrefix: string;
    curriedTypeNamePrefix: string;
    testTypeNamePrefix: string;
    specialCases: { [left: number]: string };
    compute: (left: number, right: number) => number;
}

export interface IOperatorSpec extends ICommonSpec, IPartialOperatorSpec {}

export function getExponents({ minExponent, maxExponent }: ICommonSpec): number[] {
    const exponents: number[] = [];
    for (let exponent = minExponent; exponent <= maxExponent; exponent++) {
        exponents.push(exponent);
    }
    return exponents;
}

export function isExponent(exponent: number, { minExponent, maxExponent }: ICommonSpec): boolean {
    return exponent >= minExponent && exponent <= maxExponent && exponent === Math.floor(exponent);
}

export function genFileHeader(disableTslint: boolean = true): string[] {
    const header = ["// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.", ""];
    if (disableTslint) {
        header.push("// tslint:disable", "");
    }
    return header;
}

export function genImport(symbol: string, source: string): string[] {
    return [`import { ${symbol} } from "${source}";`, ""];
}

export function genUncurriedTypeName(spec: IOperatorSpec, left?: string | number, right?: string | number): string {
    const args = left !== undefined && right !== undefined ? `<${left}, ${right}>` : "";
    return `${spec.uncurriedTypeNamePrefix}Exponents${args}`;
}
